import heapq

# Node class
class Node:
    def __init__(self, ch, freq):
        self.ch, self.freq = ch, freq
        self.left = self.right = None

    def __lt__(self, other):
        return self.freq < other.freq


# Recursive code builder
def build_codes(node, code, mapping):
    if not node:
        return
    if not node.left and not node.right:
        mapping[node.ch] = code
    build_codes(node.left, code + "0", mapping)
    build_codes(node.right, code + "1", mapping)


def huffman_encoding(text):
    # Step 1: Count character frequency
    freq = {ch: text.count(ch) for ch in text if ch != " "}
    print("\nCharacter Frequencies:", freq)

    # Step 2: Create min-heap
    heap = [Node(ch, f) for ch, f in freq.items()]
    heapq.heapify(heap)

    # Step 3: Build Huffman Tree
    while len(heap) > 1:
        left, right = heapq.heappop(heap), heapq.heappop(heap)
        merged = Node(None, left.freq + right.freq)
        merged.left, merged.right = left, right
        heapq.heappush(heap, merged)

    root = heap[0]

    # Step 4: Build Huffman codes
    codes = {}
    build_codes(root, "", codes)
    print("Huffman Codes:", codes)

    # Step 5: Encode and decode
    encoded = "".join(codes[ch] for ch in text if ch != " ")
    print("Encoded:", encoded)

    decoded, node = "", root
    for bit in encoded:
        node = node.left if bit == "0" else node.right
        if not node.left and not node.right:
            decoded += node.ch
            node = root

    print("Decoded:", decoded)


# Main
text = input("Enter a string: ")
huffman_encoding(text)

